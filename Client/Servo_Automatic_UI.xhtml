<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
  <head>
    <meta charset="utf-8" />
    <title></title>
    <link rel="stylesheet"  type="text/css" href="_ejs_library/css/ejss.css" />
    <script src="_ejs_library/scripts/common_script.js"></script>
    <script src="_ejs_library/scripts/textresizedetector.js"></script>
    <script src="_ejs_library/ejsS.v1.min.js"></script>
<script type="text/javascript"><!--//--><![CDATA[//><!--
/**
 * JSON-RPC Client
 * author: Jesus Chacon <jcsombria@gmail.com>
 *
 * Copyright (C) 2013 Jesus Chacon
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

var JsonRpcBuilder = {
  request: function(method, params, id) {
    if(params && !(params instanceof Array)) {
      throw new InvalidParamsException();
    }
    var request = {
      jsonrpc: '2.0',
      method: method
    };
    if(params !== undefined) {
      request.params = params;
    }
    if(id !== undefined) {
      request.id = id;
    }
    return request;
  },

  response: function(result, id) {
    return {
      jsonrpc: '2.0',
      result: result,
      id: id
    }
  },

  responseWithError: function(error, id) {
    return {
      jsonrpc: '2.0',
      error: error,
      id: id
    };
  },

  error: function(code, message, data) {
    return {
      code: code,
      message: message,
      data: data
    };
  }
};

function JsonRpcClient(transport) {
  this.batch = [];
  this.id = 0;

  this.setTransport(transport);
}

JsonRpcClient.prototype.setTransport = function(transport) {
  if(transport !== undefined) {
    this.transport = transport;
  }
};

// Espera respuesta por parte del servidor
JsonRpcClient.prototype.invoke = function(method, params, callback) {
  this.id ++;
  var request = JsonRpcBuilder.request(method, params, this.id.toString());
  try {
    var transport = (this.proxy != undefined) ? this.proxy : this.transport;
    transport.send(JSON.stringify(request), function _onResponse(response) {
      try {
        var result = this.parseResponse(JSON.parse(response));
        callback(result);
      } catch(error) {}
    }.bind(this));
  } catch(error) {
    console.log('[ERROR] Invalid Transport');
  }
};

// *NO* espera respuesta por parte del servidor
JsonRpcClient.prototype.notify = function(method, params, callback) {
  var request = JsonRpcBuilder.request(method, params);
  try {
    var transport = (this.proxy != undefined) ? this.proxy : this.transport;
    transport.send(JSON.stringify(request));
  } catch(error) {
    console.log('[ERROR] Invalid Transport');
  }
};

JsonRpcClient.prototype.invokeLater = function(method, params) {
  this.id++;
  var request = JsonRpcBuilder.request(method, params, this.id.toString());
  this.batch.push(request);
};

JsonRpcClient.prototype.notifyLater = function(method, params) {
  var request = JsonRpcBuilder.request(method, params);
  this.batch.push(request);
};

JsonRpcClient.prototype.sendBatch = function(callback) {
  if(this.transport === undefined || this.transport.send === undefined)
    throw new Error('[ERROR] Undefined Transport Method');
  this.transport.send(JSON.stringify(this.batch), function(response) {
    if(callback != undefined) {
      callback(JSON.parse(response));
    }
  });
  this.batch = [];
};

JsonRpcClient.prototype.parseResponse = function(response) {
  try {
    if(response.result != undefined) {
      return response.result;
    } else if(response.error != undefined) {
      return response.error;
    }
  } catch(error) {
    console.log(error);
    return error;
  }
};

// ----------------------------------------------------------------------------

/**
 * Interface Transport {
 * 	send(request, callback)
 * }
 */

/**
 * WebSocket Transport
 */

function WebSocketTransport(server) {
  this.host = 'localhost';
  this.security = false;
  if(server.host !== undefined) {
    this.setHost(server.host);
  }
//  if(server.port != undefined) {
//    this.port = server.port;
//  }
  this.url = '';
  if(server.url !== undefined) {
    this.url = server.url;
  }
  this.ws = null;
}

WebSocketTransport.prototype.setHost = function(host) {
    if (!String.prototype.startsWith) { // polyfill for IE and Edge
        String.prototype.startsWith = function(searchString, position) {
            position = position || 0;
            return this.indexOf(searchString, position) === position;
        };
    }
    if (host.startsWith('http://')) {
        this.host = host.substr(7);
        this.transport = 'http://';
        console.log("[ERROR] Wrong transport (http instead of ws/wss).");
    } else if (host.startsWith('https://')) {
        this.host = host.substr(8);
        this.transport = 'https://';
        console.log("[ERROR] Wrong transport (https instead of ws/wss).");
    } else if(host.startsWith('ws://')) {
        this.host = host.substr(5);
        this.transport = 'ws://';
    } else if(host.startsWith('wss://')) {
        this.host = host.substr(6);
        this.transport = 'wss://';
    } else {
        this.host = host;
    }
};

WebSocketTransport.prototype.send = function(request, callback) {
  if(this.ws !== undefined) {
    this.ws.send(request);
  } else {
    console.log('[ERROR]: WebSockets channel not connected.');
  }
};

WebSocketTransport.prototype.open = function(params, handler, callback) {
  if(this.ws != null) {
    console.log('[WARNING] Using previously opened WebSocket');
    return this.ws;
  }
  var url = this.transport + this.host;
  if(this.port !== undefined) {
    url += ":" + this.port;
  }
  if(this.url !== undefined) {
    url += this.url;
  }

  this.ws = new WebSocket(url);

  this.ws.onopen = function(e) {
    if(handler.open !== undefined) {
      handler.open();
    }
  };

  this.ws.onmessage = function(e) {
    try {
      if(handler.message !== undefined) {
        data = JSON.parse(e.data);
        handler.message(data);
      }
    } catch(error) {
      console.log('[ERROR]: invalid WebSockets response.');
    }
  };

  this.ws.onclose = function() {
    if(handler.close != undefined) {
      handler.close();
    } else {
      console.log('[INFO]: Websocket connection closed');
    }
  };

  this.ws.onerror = function(e) {
    if(error != undefined) {
      error(e.data);
    } else {
      console.log('[ERROR]: Websocket connection closed');
    }
  };

  return this.ws;
};

WebSocketTransport.prototype.close = function() {
  this.ws.close();
};

/**
* HTTP Transport
*/

function HttpTransport(host, port, url) { // implements Transport
  this.configure(host, port, url);
}

HttpTransport.prototype = {
  host: 'localhost',
  port: 2055,
  url: '/',
  transport: 'http://',

  configure: function(host, port, url) {
    this.setHost(host);
    if(port != undefined && port > 0 && port < 65535) {
      this.port = port;
    } else {
      this.port = undefined;
    }
    if(url != undefined) {
      this.url = url;
    }
  },

  setHost: function(host) {
    if (!String.prototype.startsWith) { // polyfill for IE and Edge
        String.prototype.startsWith = function(searchString, position) {
            position = position || 0;
            return this.indexOf(searchString, position) === position;
        };
    }
    if (host.startsWith('http://')) {
      this.host = host.substr(7);
      this.transport = 'http://';
    } else if (host.startsWith('https://')) {
      this.host = host.substr(8);
      this.transport = 'https://';
    } else if(host.startsWith('ws://')) {
      console.log("[ERROR] Wrong transport (ws instead of http/https).");
      this.host = host.substr(5);
      this.transport = 'ws://';
    } else if(host.startsWith('wss://')) {
      console.log("[ERROR] Wrong transport (wss instead of http/https).");
      this.host = host.substr(6);
      this.transport = 'wss://';
    } else {
      this.host = host;
      this.transport = 'http://';
    }
  },

  send: function(request, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', this.getURL(), true);
    xhr.onload = function (e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          if(xhr.response != undefined) {
            if(callback != undefined) {
              callback(xhr.response);
            }
          }
        } else {
//          console.error(xhr.statusText);
        }
      }
    };
    xhr.onerror = function (e) {
      console.log(e);
    };
    xhr.send(request);
  },

  getURL: function(url) {
    if(url == undefined) {
      url = (this.url == undefined) ? '/' : this.url;
    }
    if(!url.startsWith('/')) {
      url = '/' + url;
    }
    if(this.port != 80 && this.port != undefined) {
      return this.transport + this.host + ':' + this.port + url;
    }
    var hostEndsWithSlash = (this.host.charAt(this.host.length-1) == '/');
    var host = hostEndsWithSlash ? this.host.substr(0, this.host.length-1) : this.host;
    return this.transport + host + url;
  }
};


/**
* HTTP-SSE Transport
*/

function SSETransport(conf) {
  conf['port'] = undefined;
  conf['urlPOST'] = '/RIP/POST';
  conf['urlSSE'] = '/RIP/SSE';
  HttpTransport.call(this, conf.host, conf.port, conf.urlPOST);
  this.pathSSE = conf['urlSSE'];
  if(this.port != undefined) {
    this.urlSSE = this.transport + this.host + ':' + this.port + conf.urlSSE;
  } else {
    this.urlSSE = this.transport + this.host + conf.urlSSE;
  }
}

SSETransport.prototype = Object.create(HttpTransport.prototype);

/*
  Creates a new SSE connection.
*/
SSETransport.prototype.open = function(params, handler, callback) {
  var baseurl = this.getURL(this.pathSSE);
  var url = this.addParams(baseurl, params);
  if(typeof(EventSource) !== "undefined") {
    //source = new EventSource(encodeURI(url), {withCredentials: true});
    source = new EventSource(encodeURI(url));
  } else {
    alert("SSE are not supported by your browser!");
  }

  source.onopen = function(e) {
    if(handler.open != undefined) {
      handler.open();
    }
  };

  source.addEventListener('periodiclabdata', function(e) {
    try {
      var parsed = JSON.parse(e.data);
      if(handler.message != undefined) {
        handler.message(parsed);
      }
    } catch(error) {
      console.log('[ERROR] invalid SSE response.');
    }
  }, false);

  source.addEventListener('CLOSE', function(e) {
    try {
      var parsed = JSON.parse(e.data);
      console.log(parsed.error);
    } catch (error) {}
    console.log('Closing');
    source.close();
    }, false);

  return source;
};

SSETransport.prototype.addParams = function (url, params) {
  if(params != undefined) {
    var paramsString = '', first = true;
    for(var param in params) {
      if(first) {
        paramsString += '?' + param + '=' + params[param];
      } else {
        paramsString += '&' + param + '=' + params[param];
      }
      first = false;
    }
  }
  return url + paramsString;
};

// ----------------------------------------------------------------------------

/**
* RIP Client
*/

function RIPClient(transport) {
  this.transport = transport;
  /*var transport = new SSETransport({
    'host': host,
    'port': port,
    'portSSE': 8080,
    'urlSSE': '/RIP/SSE',
    'urlPOST': '/RIP/POST',
  });*/
  var ripclient = new JsonRpcClient(transport);
  ripclient.connected = false;
  ripclient.buffer = [];
  ripclient.BUFFER_SIZE = 2000;


  ripclient.methods = {
    get: 'get', // Get some variables from the server
    set: 'set', // Set some variables in the server
    start: 'start', // Start a new Experience
    stop: 'stop', // Stop a running Experience
    info: 'info'
  };

  ripclient.setDefaultExperience = function(expid) {
    this.expid = expid;
  };

  ripclient.info = function(callback, expid) {
    if(expid == undefined || expid == null) {
      this.invoke(this.methods.info, [], callback);
    } else {
      this.invoke(this.methods.info, [expid], callback);
    }
  };

  ripclient.start = function(callback, expid) {
    expid = this.checkExpid(expid);
    if(expid == undefined) { return }
    this.invoke(this.methods.start, [expid], callback);
  };

  ripclient.checkExpid = function(expid) {
    return (expid != undefined) ? expid : this.expid;
  };

  ripclient.stop = function(callback, expid) {
    expid = this.checkExpid(expid);
    if(expid == undefined) { return }
    return this.invoke(this.methods.stop, [expid], callback);
  };

  ripclient.get = function(vars, callback, expid) {
    expid = this.checkExpid(expid);
    if(expid == undefined) { return }
    this.invoke(this.methods.get, [expid, vars], callback);
  };

  ripclient.set = function(vars, values, callback, expid) {
    expid = this.checkExpid(expid);
    if(expid == undefined) { return }
    this.invoke(this.methods.set, [expid, vars, values], callback);
  };

  ripclient.connect = function(expid, callback) {
    expid = this.checkExpid(expid);
    if(expid == undefined) { return }
    this.expid = expid;
    this.userOnMessage = callback;
    this.session = this.transport.open({'expId':expid}, {
      'open': this.onopen.bind(this),
      'message': this.ondata.bind(this)
    });
  };

  ripclient.onopen = function(data) {
    this.connected = true;
  };

  ripclient.ondata = function(data) {
    try {
      var result = data.result;
      var names = result[0];
      var values = result[1];
      var n = names.length;
      var notifyUser = (this.userOnMessage != undefined);
      for(var i = 0; i<n; i++) {
        ripclient[names[i]] = values[i];
        data[names[i]] = values[i];
      }
      if(this.buffer.length < this.BUFFER_SIZE) {
        this.buffer.push(data);
      }
      if(notifyUser) {
        this.userOnMessage(data);
      }
    } catch(error) {
      console.log(error);
    }
  };

  ripclient.disconnect = function() {
    this.connected = false;
    this.session.close();
  };

  ripclient.autobuildUI = function(meta, generalPlacing, labelInRow) {
    // TODO: Allow drag&drop, use _model.getView()._addElement() instead so refresh/update of variables is straightforward...

    // Re-arrange DOM elements and create new ones according to the placing selected in the element config
    const auto = prepareAutoBuild(generalPlacing);

    // Build new DOM elements for writables and readables
    let writables = createWritableElements(meta, generalPlacing, labelInRow);
    let readables = createReadableElements(meta, generalPlacing, labelInRow);

    // Add newly built elements to DOM and style them according to preferences
    const writablesPanel = arrangeWritableElements(generalPlacing, writables);
    const readablesPanel = arrangeReadableElements(generalPlacing, readables);
    placeWritablesAndReadables(auto, generalPlacing, writablesPanel, readablesPanel);

    // Fix writable subpanel width for layouts that need it
    if ((generalPlacing !== 0 && generalPlacing !== 1) || !labelInRow) fixSubpanelWidth();

    // Update readables and writables in/from view
    updateReadables(meta.readables.list);
    updateWritables(meta.writables.list);

    ///////////////////////////////////////////////////////////////////////////////////////////////////////

    // Functions
    function prepareAutoBuild(placing) {
      const oldtop = document.getElementById("_topFrame");
      const newtop = oldtop.cloneNode(false);
      oldtop.id = "_oldTopFrame";
      let style = "display: flex; justify-content: center; align-items: center; align-content: center; ";
      switch (placing) {
        case 0:
          style += "flex-direction: column-reverse;";
          break;
        case 1:
          style += "flex-direction: column;";
          break;
        case 2:
          style += "flex-direction: row-reverse;";
          break;
        case 3:
          style += "flex-direction: row;";
          break;
      }
      newtop.setAttribute("style", style);
      const auto = document.createElement('div');
      auto.id = "_autobuilt";
      newtop.appendChild(oldtop);
      newtop.appendChild(auto);
      document.body.prepend(newtop);
      return auto;
    }

    function createWritableElements(meta, generalPlacing, row) {
      let writables = Array();
      for (let i = 0; i < meta.writables.list.length; i++) {
        if (meta.writables.list[i].type === "unsupported") {
          continue;
        }
        const writablePanel = createPanel(generalPlacing, meta.writables.list[i].type, row);
        if (meta.writables.list[i].type !== "boolean") {
          const writableSubpanel = createSubpanel();
          const writableLabel = createLabel(meta.writables.list[i].name, meta.writables.list[i].description);
          const writableInput = createWritableInput(meta.writables.list[i]);
          writableSubpanel.appendChild(writableLabel);
          writableSubpanel.appendChild(writableInput);
          writablePanel.appendChild(writableSubpanel);
        }
        const writableElement = createElement(meta.writables.list[i], false);
        writablePanel.appendChild(writableElement);
        writables.push(writablePanel);
      }
      return writables;
    }

    function createReadableElements(meta, generalPlacing, row) {
      let readables = Array();
      for (let i = 0; i < meta.readables.list.length; i++) {
        if (meta.readables.list[i].type === "unsupported") {
          continue;
        }
        const readablePanel = createPanel(generalPlacing, meta.readables.list[i].type, row);
        const readableLabel = createLabel(meta.readables.list[i].name, meta.readables.list[i].description);
        const readableElement = createElement(meta.readables.list[i], true);
        if (meta.readables.list[i].type !== "boolean") readablePanel.appendChild(readableLabel);
        readablePanel.appendChild(readableElement);
        readables.push(readablePanel);
      }
      return readables;
    }

    function arrangeWritableElements(generalPlacing, writables) {
      const writablesPanel = document.createElement('div');
      let style = "display: flex; "
      if (generalPlacing === 0 || generalPlacing === 1) style += "flex-direction: row; flex-wrap: wrap; ";
      else style += "flex-direction: column; ";
      style += "justify-content: center; align-items: stretch; align-content: stretch; ";
      writablesPanel.setAttribute("style", style);
      for (let i = 0; i < writables.length; i++) {
        writablesPanel.appendChild(writables[i]);
      }
      return writablesPanel;
    }

    function arrangeReadableElements(generalPlacing, readables) {
      const readablesPanel = document.createElement('div');
      let style = "display: flex; "
      if (generalPlacing === 0 || generalPlacing === 1) style += "flex-direction: row; flex-wrap: wrap; ";
      else style += "flex-direction: column; ";
      style += "justify-content: center; align-items: stretch; align-content: stretch; ";
      readablesPanel.setAttribute("style", style);
      for (let i = 0; i < readables.length; i++) {
        readablesPanel.appendChild(readables[i]);
      }
      return readablesPanel;
    }

    function placeWritablesAndReadables(auto, generalPlacing, writablesPanel, readablesPanel) {
      let style = "display: flex; "
      if (generalPlacing === 0 || generalPlacing === 1) style += "flex-direction: column; ";
      else style += "flex-direction: row; flex-wrap: wrap;";
      style += "justify-content: center; align-items: center; align-content: center;";
      auto.setAttribute("style", style);
      auto.appendChild(writablesPanel);
      auto.appendChild(readablesPanel);
    }

    function createPanel(generalPlacing, type, row) {
      const panel = document.createElement("div");
      let style = "display: flex; align-items: center; align-content: center; margin: 4px; ";
      if (generalPlacing === 0 || generalPlacing === 1 || type === "boolean") {
        style += "justify-content: center; ";
      } else {
        style += "justify-content: space-between; ";
      }
      if (row) {
        style += "flex-direction: row;";
      } else {
        style += "flex-direction: column;";
      }
      panel.setAttribute("style", style);
      return panel;
    }

    function createSubpanel() {
      const panel = document.createElement("div");
      let style = "display: flex; justify-content: space-between; align-items: center; align-content: center; width: 100%;";
      panel.setAttribute("style", style);
      panel.setAttribute("class", "subPanelWritable");
      return panel;
    }

    function fixSubpanelWidth() {
      let maxWidth = 0;
      let subpanels = document.getElementsByClassName("subPanelWritable");
      let subPanelWidth;
      for (let i = 0; i < subpanels.length; i++) {
        subPanelWidth = subpanels[i].offsetWidth;
        if (subPanelWidth > maxWidth) maxWidth = subPanelWidth;
      }
      for (let i = 0; i < subpanels.length; i++) {
        subpanels[i].style.minWidth = maxWidth + 'px';
      }
    }

    function createLabel(name, description) {
      const label = document.createElement("label");
      label.setAttribute("id", name + ".label");
      label.setAttribute("title", description);
      label.innerHTML = name;
      return label;
    }

    function createWritableInput(meta) {
      const input = document.createElement("input");
      let type = "number";
      let style = "max-width: 60px; margin-left: 3px;";
      input.setAttribute("style", style);
      input.setAttribute("type", type);
      input.setAttribute("id", meta.name + "." + type);
      input.setAttribute("title", meta.description);
      if (meta.name !== "Setpoint") {
        input.setAttribute("value", meta.min); // TODO: Receive init value from RIP and set value here
      } else {
        input.setAttribute("value", "0"); // TODO: Remove this ad-hoc case
      }
      return input;
    }

    function createElement(meta, readable) {
      const element = document.createElement("input");
      let type = "";
      let style = "";
      if (meta.type === "boolean") {
        element.setAttribute("value", meta.name);
        style += "height: 100%; ";
        type = "button";
      } else {
        if (readable) {
          type = "number";
          element.setAttribute("readonly", "");
          style += "background: whitesmoke; width: 80px;";
        } else {
          type = "range";
          style += "vertical-align: middle; width: 100%;";
          if (meta.min !== '-Inf') {
            element.setAttribute("min", meta.min);
            if (meta.name !== "Setpoint") {
              element.setAttribute("value", meta.min); // TODO: Receive init from RIP value and set value here
            } else {
              element.setAttribute("value", "0"); // TODO: Remove this ad-hoc case
            }
          }
          if (meta.max !== 'Inf') {
            element.setAttribute("max", meta.max);
          }
          if (meta.precision !== '0') {
            element.setAttribute("step", meta.precision);
          }
        }
      }
      element.setAttribute("style", style);
      element.setAttribute("type", type);
      element.setAttribute("id", meta.name + "." + type);
      element.setAttribute("title", meta.description);
      return element;
    }

    function updateReadables(readables) {
      let timeout = 1000 / _model.getFPS(); // TODO: Get sampling rate for variable from metadata and use the bigger one
      for (let i = 0; i < readables.length; i++) {
        if (readables[i].type === "unsupported") {
          continue;
        }
        let type = "number";
        if (readables[i].type === "boolean") {
          type = "button";
        }
        setInterval(function(){
              let readable = document.getElementById(readables[i].name + "." + type);
              if (readable !== null) readable.value = _model._rip[readables[i].name];},
            timeout);
      }
    }

    function updateWritables(writables) {
      for (let i = 0; i < writables.length; i++) {
        if (writables[i].type === "unsupported") {
          continue;
        }
        let type = "range";
        if (writables[i].type === "boolean") {
          type = "button";
        }
        let name = writables[i].name;
        let writable = document.getElementById(name + "." + type);
        if (type === "button") {
          if (writable !== null) {
            writable.setAttribute("onclick", "_model._rip.set(['" + name + "'], ['true'])");
          }
        }
        if (type === "range") {
          if (writable !== null) {
            const functionsRange = "_model._rip.set(['" + name + "'], [this.value]); " +
                "document.getElementById('" + name + ".number" + "').value = this.value";
            writable.setAttribute("oninput", functionsRange);
            writable.setAttribute("onchange", functionsRange);
          }
          let writable2 = document.getElementById(name + ".number");
          if (writable2 !== null) {
            const functionsNumber = "_model._rip.set(['" + name + "'], [this.value]); " +
                "document.getElementById('" + name + ".range" + "').value = this.value";
            writable2.setAttribute("oninput", functionsNumber);
            writable2.setAttribute("onchange", functionsNumber);
          }
        }
      }
    }
  }

  return ripclient;
}

/**
 * Arduino API
 */
function RIPArduino(transport) {
  this.transport = transport;
  //Input digitals pin Arduino
  this.DI = [].fill(false, 1, 54);
  this.DI[2]=true;
  //Output digitals pin Arduino
  this.DO = [].fill(false, 1, 54);
  //Input analogs pin Arduino
  this.AI = [].fill(0, 1, 16);
  //Out analogs pin Arduino
  this.AO = [].fill(0, 1, 54);
}

RIPArduino.prototype.setDefaultExperience = function(expid) {
    this.expid = expid;
};

RIPArduino.prototype.connect = function() {
  params = {};
  handler = {
    'open':this.onopen.bind(this),
    'message':this.onmessage.bind(this),
    'error':this.onerror.bind(this)
  };
  this.transport.open(params, handler);
};

RIPArduino.prototype.onopen = function (data) {
  this.connected = true;
  console.log('[INFO] Opening WebSocket connection.');
};

RIPArduino.prototype.onmessage = function (data) {
  try {
    if(data.orden.mode == 1) {
      this.performerCommand(data);
    } else if(data.orden.mode === 0) {
      this.performerResponse(data);
    }
  } catch(error) {
    console.log('[WARNING] Discarding unknown or invalid message.');
  }
};

RIPArduino.prototype.onerror = function (data) {
  console.log('[ERROR] Error on WebSocket connection.');
};

RIPArduino.prototype.digitalWrite = function(ind, value) {
  var command = 'digitalWrite';
  var params = [ind, value];
  var id = this.getId();
  var request = this.buildRequest(command, params, id);
  this.transport.send(JSON.stringify(request));
};

RIPArduino.prototype.buildRequest = function(method, params, id) {
  var request = {
    "orden" : {
      "mode" : 1,
      "idSecuent" : id,
      "command" : method,
      "parameters" : params
    }
  };
  return request;
};

RIPArduino.prototype.analogWrite = function(ind, value) {
  var command = 'analogWrite';
  var params = [ind, value];
  var id = this.getId();
  var request = this.buildRequest(command, params, id);
  this.transport.send(JSON.stringify(request));
};

RIPArduino.prototype.servoWrite = function(ind, value) {
    var command = 'servoWrite';
    var params = [ind, value];
    var id = this.getId();
    var request = this.buildRequest(command, params, id);
    this.transport.send(JSON.stringify(request));
};

RIPArduino.prototype.getId = function() {
  return Math.floor(Math.random()*1000);
};

RIPArduino.prototype.putAnalogValue = function(ind, value) {
  var command = 'putAnalogValue';
  var params = [ind, value];
  var id = this.getId();
  var request = this.buildRequest(command, params, id);
  this.transport.send(JSON.stringify(request));
};

RIPArduino.prototype.putDigitalValue = function(ind, value) {
  var command = 'putDigitalValue';
  var params = [ind, value];
  var id = this.getId();
  var request = this.buildRequest(command, params, id);
  this.transport.send(JSON.stringify(request));
};

RIPArduino.prototype.digitalRead = function(ind) {
  return this.DI[ind];
};

RIPArduino.prototype.analogRead = function(ind) {
  return this.AI[ind];
};

RIPArduino.prototype.upDateDigitalOut = function(ind) {
  return this.DO[ind];
};

RIPArduino.prototype.upDateAnalogOut = function(ind) {
  return this.AO[ind];
};

RIPArduino.prototype.performerCommand = function(obj) {
  switch(obj.orden.command) {
    case "log":
      value = value + obj.orden.parameters[1] + "\r\n";
      break;
    case "digitalRead":
        this.DI = obj.orden.parameters;
        break;
    case "analogRead":
      this.AI = obj.orden.parameters;
      break;
    default:
      text = "...";
  }
};

RIPArduino.prototype.performerResponse = function(obj) {
  switch(obj.orden.command) {
    case "digitalWrite":
      this.DO[obj.orden.parameters[0]] = obj.orden.parameters[1];
      break;
    case "analogWrite":
      this.AO[obj.orden.parameters[0]] = obj.orden.parameters[1];
    break;
    default:
     text = "...";
  }
};
//--><!]]></script>

<script type="text/javascript"><!--//--><![CDATA[//><!--
/* _inputParameters: an object with different values for the model parameters */
function testRIPLocal(_topFrame,_libraryPath,_codebasePath, _inputParameters) {
  var _model = EJSS_CORE.createAnimationLMS();
  var _view;
  var _isPlaying = false;
  var _isPaused = true;
  var _isMobile = (navigator===undefined) ? false : navigator.userAgent.match(/iPhone|iPad|iPod|Android|BlackBerry|Opera Mini|IEMobile/i);

var _stringProperties = {};
  var _tools = {
    showInputDialog : EJSS_INTERFACE.BoxPanel.showInputDialog,
    showOkDialog : EJSS_INTERFACE.BoxPanel.showOkDialog,
    showOkCancelDialog : EJSS_INTERFACE.BoxPanel.showOkCancelDialog,
    downloadText: EJSS_TOOLS.File.downloadText,
    uploadText: function(action) { EJSS_TOOLS.File.uploadText(_model,action); } 
  };

var __conf = {'host':'http://localhost:8080','port':'8080'};
var __transport = new SSETransport(__conf);
_model.rip = new RIPClient(__transport);
_model._rip = _model.rip;
var rip = _model.rip;
_model.rip.setDefaultExperience('Motor');
_model.rip.__connect__ = _model.rip.connect;
_model.rip.connect = function(expid, callback) {
	if(callback != undefined) {
		this.__connect__(expid, function(response) {
			this.updateEjsVariables(response);
			callback(response);
		});
	} else {
		this.__connect__(expid, this.updateEjsVariables);
	}
};
// Auto-generated method Update
rip.updateEjsVariables = function(result) {
	position = result['Position'];
voltage = result['Voltage'];
t = result['Time'];

	_model.getView()._update();
}
// Auto-generated method Init
rip.init = function(callback) {
	this.post('eval', ['']);
	this.sync(function(response) {
		this._isConnected = (response[0].result !== undefined);
		if(callback != undefined) {
			callback();
		};
	}.bind(this));
}
rip._isConnected = false
rip.isConnected = function() {
	return this._isConnected;}
// Auto-generated method step()
rip.step = function(callback) {
	this.post('set', [['Kc','Td','Ti','Disturbance','Setpoint','Reset control'], [kc,td,ti,disturbance,setpoint,reset]]);
	this.post('eval', ['']);
	this.post('step', [1]);
	this.post('get', [['Position','Voltage','Time']]);
	this.sync(function(response) {
		var result = response[3].result;
		position = result[0][0];
voltage = result[1][0];
t = result[2][0];

		if(callback != undefined) {
			callback(result);
		}
	});
}
_model.rip.info(function(data){_model.rip.autobuildUI(data, 1, false);}, "Motor");

  function _play()  { _isPaused = false; _isPlaying = true;  _model.play();  }
  function _pause() { _isPaused = true;  _isPlaying = false; _model.pause(); }
  function _step()  { _pause();  _model.step(); }
  function _reset() { _model.reset();  _isPaused = _model.isPaused(); _isPlaying = _model.isPlaying(); }
  _model._play  = _play;
  _model._pause = _pause;
  _model._step  = _step;
  _model._reset = _reset;
  function _update() { _model.update(); }
  function _initialize() { _model.initialize(); }
  function _setFPS(_fps) { _model.setFPS(_fps); }
  function _setDelay(_delay) { _model.setDelay(_delay); }
  function _setStepsPerDisplay(_spd) { _model.setStepsPerDisplay(_spd); }
  function _setUpdateView(_updateView) { _model.setUpdateView(_updateView); }
  function _setAutoplay(_auto) { _model.setAutoplay(_auto); }
  function _println(_message) { console.log(_message); }

  function _breakAfterThisPage() { _model.setShouldBreak(true); }

  function _resetSolvers() { if (_model.resetSolvers) _model.resetSolvers(); }

  function _saveText(name,type,content) { if (_model.saveText) _model.saveText(name,type,content); }

  function _saveState(name) { if (_model.saveState) _model.saveState(name); }

  function _saveImage(name,panelname) { if (_model.saveImage) _model.saveImage(name,panelname); }

  function _readState(url,type) { if (_model.readState) _model.readState(url,type); }

  function _readText(url,type,varname) { if (_model.readText) _model.readText(url,type,varname); }

  function _getStringProperty(propertyName) {
    var _value = _stringProperties[propertyName];
    if (_value===undefined) return propertyName;
    else return _value;
  }
  var __pagesEnabled = [];
  function _setPageEnabled(pageName,enabled) { __pagesEnabled[pageName] = enabled; }

  var kc; // EjsS Model.Variables.Controls.kc
  var td; // EjsS Model.Variables.Controls.td
  var ti; // EjsS Model.Variables.Controls.ti
  var setpoint; // EjsS Model.Variables.Controls.setpoint
  var disturbance; // EjsS Model.Variables.Controls.disturbance
  var reset; // EjsS Model.Variables.Controls.reset

  var t; // EjsS Model.Variables.Indicators.t
  var position; // EjsS Model.Variables.Indicators.position
  var voltage; // EjsS Model.Variables.Indicators.voltage

  _model.getOdes = function() { return []; };

  _model.removeEvents = function(){
  };

  function _serialize() { return _model.serialize(); }

  _model._userSerialize = function() {
    return {
      kc : kc,
      td : td,
      ti : ti,
      setpoint : setpoint,
      disturbance : disturbance,
      reset : reset,
      t : t,
      position : position,
      voltage : voltage
    };
  };

  _model._readParameters = function(json) {
    if(typeof json.kc != "undefined") kc = json.kc;
    if(typeof json.td != "undefined") td = json.td;
    if(typeof json.ti != "undefined") ti = json.ti;
    if(typeof json.setpoint != "undefined") setpoint = json.setpoint;
    if(typeof json.disturbance != "undefined") disturbance = json.disturbance;
    if(typeof json.reset != "undefined") reset = json.reset;
    if(typeof json.t != "undefined") t = json.t;
    if(typeof json.position != "undefined") position = json.position;
    if(typeof json.voltage != "undefined") voltage = json.voltage;
  };

  _model._inputAndPublicParameters = ["t",  "position",  "voltage"]; 

  _model._outputAndPublicParameters = ["kc",  "td",  "ti",  "setpoint",  "disturbance",  "reset"];

  function _unserialize(json) { return _model.unserialize(json); }

  _model._userUnserialize = function(json) {
    _model._readParameters(json);
   _resetSolvers();
   _model.update();
  };

  _model.addToReset(function() {
    __pagesEnabled["Connect"] = true;
    __pagesEnabled["P치gina Evoluci칩n"] = true;
  });

  _model.addToReset(function() {
    kc = 0; // EjsS Model.Variables.Controls.kc
    td = 0; // EjsS Model.Variables.Controls.td
    ti = 0; // EjsS Model.Variables.Controls.ti
    setpoint = 0; // EjsS Model.Variables.Controls.setpoint
    disturbance = 0; // EjsS Model.Variables.Controls.disturbance
    reset = false; // EjsS Model.Variables.Controls.reset
  });

  _model.addToReset(function() {
    t = 0; // EjsS Model.Variables.Indicators.t
    position = 0; // EjsS Model.Variables.Indicators.position
    voltage = 0; // EjsS Model.Variables.Indicators.voltage
  });

  if (_inputParameters) {
    _inputParameters = _model.parseInputParameters(_inputParameters);
    if (_inputParameters) _model.addToReset(function() { _model._readParameters(_inputParameters); });
  }

  _model.addToReset(function() {
    _model.setAutoplay(true);
    _model.setPauseOnPageExit(true);
    _model.setFPS(20);
    _model.setStepsPerDisplay(1);
  });

  _model.addToInitialization(function() {
    if (!__pagesEnabled["Connect"]) return;
    rip.connect();  // > Initialization.Connect:1
  });

  _model.addToEvolution(function() {
    if (!__pagesEnabled["P치gina Evoluci칩n"]) return;
  });

  _model.addToFixedRelations(function() { _isPaused = _model.isPaused(); _isPlaying = _model.isPlaying(); });

  _model.addToFixedRelations(function() { _isPaused = _model.isPaused(); _isPlaying = _model.isPlaying(); });

    _model._fontResized = function(iBase,iSize,iDelta) {
      _view._fontResized(iBase,iSize,iDelta);
  }; // end of _fontResized

  function _getViews() {
    var _viewsInfo = [];
    var _counter = 0;
    _viewsInfo[_counter++] = { name : "HtmlView Page", width : 800, height : 600 };
    return _viewsInfo;
  } // end of _getViews

  function _selectView(_viewNumber) {
    _view = null;
    _view = new testRIPLocal_View(_topFrame,_viewNumber,_libraryPath,_codebasePath);
    var _view_super_reset = _view._reset;
    _view._reset = function() {
      _view_super_reset();
      switch(_viewNumber) {
        case -10 : break; // make Lint happy
        default :
        case 0:
          _view.Disco.linkProperty("Transformation",  function() { return -position; } ); // HtmlView Page linking property 'Transformation' for element 'Disco'
          break;
      } // end of switch
    }; // end of new reset

    _model.setView(_view);
    _model.reset();
    _view._enableEPub();
  } // end of _selectView

  _model.setAutoplay(true);
  _model.setFPS(20);
  _model.setStepsPerDisplay(1);
  _selectView(_model._autoSelectView(_getViews())); // this includes _model.reset()
  return _model;
}

function testRIPLocal_View (_topFrame,_viewNumber,_libraryPath,_codebasePath) {
  var _view;
  switch(_viewNumber) {
    case -10 : break; // make Lint happy
    default :
    case 0: _view = testRIPLocal_View_0 (_topFrame); break;
  } // end of switch

  if (_codebasePath) _view._setResourcePath(_codebasePath);

  if (_libraryPath) _view._setLibraryPath(_libraryPath);


  return _view;
} // end of main function

function testRIPLocal_View_0 (_topFrame) {
  var _view = EJSS_CORE.createView(_topFrame);

  _view._reset = function() {
    _view._clearAll();
    _view._addElement(EJSS_INTERFACE.panel,"main", _view._topFrame) // EJsS HtmlView.HtmlView Page: declaration of element 'main'
      ;

    _view._addElement(EJSS_DRAWING2D.drawingPanel,"panelDibujo", _view.main) // EJsS HtmlView.HtmlView Page: declaration of element 'panelDibujo'
      .setProperty("Background","White") // EJsS HtmlView.HtmlView Page: setting property 'Background' for element 'panelDibujo'
      .setProperty("SquareAspect",true) // EJsS HtmlView.HtmlView Page: setting property 'SquareAspect' for element 'panelDibujo'
      .setProperty("LineWidth",0) // EJsS HtmlView.HtmlView Page: setting property 'LineWidth' for element 'panelDibujo'
      .setProperty("GuttersLineWidth",0) // EJsS HtmlView.HtmlView Page: setting property 'GuttersLineWidth' for element 'panelDibujo'
      ;

    _view._addElement(EJSS_DRAWING2D.image,"Disco", _view.panelDibujo) // EJsS HtmlView.HtmlView Page: declaration of element 'Disco'
      .setProperty("SizeX",1.8) // EJsS HtmlView.HtmlView Page: setting property 'SizeX' for element 'Disco'
      .setProperty("ImageUrl","./servo.jpg") // EJsS HtmlView.HtmlView Page: setting property 'ImageUrl' for element 'Disco'
      .setProperty("Visibility",true) // EJsS HtmlView.HtmlView Page: setting property 'Visibility' for element 'Disco'
      .setProperty("SizeY",1.8) // EJsS HtmlView.HtmlView Page: setting property 'SizeY' for element 'Disco'
      ;

  };

  return _view;
}


//--><!]]></script>
  </head>
  <body>
    <div role="button" id="_topFrame" style="text-align:center"></div>
  <div id="metadata" class="metadata">
    <br />
    <div id="title_author">
      <hr />
      <b>Title and author:</b>
      <p>
      </p>
      <p>
 Author name
      </p>
    </div>
    <hr />
    <p></p>
    <div id="copyright_message">
      <div class="cc_left"  style="float:left">&#169; 2022, Author name.</div>
      <div class="cc_right" style="float:right">    Released under a <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.en_US"> <img alt="Creative Commons Attribution-NonCommercial-ShareAlike" src="_ejs_library/images/cc_icon.png" /> </a> license.</div>
    </div>
  </div>
    <script type="text/javascript"><!--//--><![CDATA[//><!--
      var _model;
      var _scorm;
      window.addEventListener('load',
        function () { 
          _model =  new testRIPLocal("_topFrame","_ejs_library/",null);
          if (typeof _isApp !== "undefined" && _isApp) _model.setRunAlways(true);
          TextResizeDetector.TARGET_ELEMENT_ID = '_topFrame';
          TextResizeDetector.USER_INIT_FUNC = function () {
            var iBase = TextResizeDetector.addEventListener(function(e,args) {
              _model._fontResized(args[0].iBase,args[0].iSize,args[0].iDelta);
              },null);
            _model._fontResized(iBase);
          };
          _model.onload();
        }, false);
    //--><!]]></script>
  </body>
</html>
